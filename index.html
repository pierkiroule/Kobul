<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>BubbleBrush — Kobul</title>
  <style>
    :root {
      --bg: radial-gradient(1200px 800px at 50% 40%, #0b1030 0%, #05060c 45%, #02030a 100%);
      --panel: rgba(10, 12, 20, 0.55);
      --stroke: rgba(255, 255, 255, 0.16);
      --muted: rgba(240, 245, 255, 0.72);
      --bright: rgba(245, 250, 255, 0.95);
    }
    html, body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      overflow: hidden;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, sans-serif;
      color: var(--bright);
    }
    a-scene {
      position: fixed;
      inset: 0;
    }
    #overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #reticle {
      width: 22px;
      height: 22px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 50%;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.04);
      backdrop-filter: blur(4px);
    }
    #toast {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 14px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--panel);
      color: var(--muted);
      font-size: 12px;
      letter-spacing: 0.25px;
      line-height: 1.35;
      pointer-events: none;
      text-align: center;
      max-width: 620px;
      margin: 0 auto;
    }
    #selectedHint {
      position: fixed;
      top: 14px;
      left: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--panel);
      color: var(--bright);
      font-size: 12px;
      letter-spacing: 0.25px;
      max-width: 240px;
      pointer-events: none;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
</head>
<body>
  <a-scene renderer="colorManagement: true; physicallyCorrectLights: true" shadow="type: pcfsoft" background="color: #02030a">
    <a-entity id="sky" geometry="primitive: sphere; radius: 1000" material="color: #040615; side: back; shader: flat"></a-entity>
    <a-entity light="type: ambient; color: #cfd8ff; intensity: 0.3"></a-entity>
    <a-entity light="type: directional; color: #d9e4ff; intensity: 0.7" position="5 6 7"></a-entity>

    <a-entity id="rig" position="0 1.6 6">
      <a-entity id="cam" camera="fov: 84" look-controls wasd-controls-enabled="false" position="0 0 0"></a-entity>
    </a-entity>

    <a-entity id="bubbleRoot"></a-entity>
    <a-entity id="linkRoot" network-links></a-entity>
  </a-scene>

  <div id="overlay"><div id="reticle" aria-hidden="true"></div></div>
  <div id="selectedHint">aucune bulle sélectionnée</div>
  <div id="toast">Tap = nouvelle bulle • Tap sur une bulle = sélectionner • Tap sur une autre = lier • Tap long = changer la taille • Glisser = déplacer la bulle sélectionnée</div>

  <script>
    const rand = (a, b) => a + Math.random() * (b - a);
    const palette = [
      '#9ad5ff', '#f3c8ff', '#b6f3ff', '#ffc9d9', '#d4e5ff', '#c2f3e8'
    ];

    AFRAME.registerSystem('bubble-network', {
      init() {
        this.nodes = [];
        this.links = [];
        this.selected = null;
        this.linkRoot = document.getElementById('linkRoot');
        this.bubbleRoot = document.getElementById('bubbleRoot');
      },
      addNode(el) {
        this.nodes.push(el);
      },
      removeNode(el) {
        this.nodes = this.nodes.filter(n => n !== el);
        this.links = this.links.filter(l => {
          const match = l.a === el || l.b === el;
          if (match) l.el.remove();
          return !match;
        });
      },
      select(el) {
        this.selected = el;
        document.getElementById('selectedHint').textContent = el ? `bulle ${el.dataset.id} sélectionnée` : 'aucune bulle sélectionnée';
        this.nodes.forEach(n => n.emit('bubble-deselected'));
        if (el) el.emit('bubble-selected');
      },
      link(a, b) {
        if (!a || !b || a === b) return;
        const existing = this.links.find(l => (l.a === a && l.b === b) || (l.a === b && l.b === a));
        if (existing) return;
        const link = document.createElement('a-cylinder');
        link.setAttribute('radius', '0.05');
        link.setAttribute('material', 'color: #e5edff; opacity: 0.25; side: double');
        link.classList.add('link');
        this.linkRoot.appendChild(link);
        this.links.push({ a, b, el: link });
        this.updateLink(link, a.object3D.position, b.object3D.position);
      },
      updateLink(linkEl, pa, pb) {
        const obj = linkEl.object3D;
        const dir = new AFRAME.THREE.Vector3().subVectors(pb, pa);
        const dist = dir.length();
        if (!dist) return;
        const mid = new AFRAME.THREE.Vector3().addVectors(pa, pb).multiplyScalar(0.5);
        obj.position.copy(mid);
        linkEl.setAttribute('height', dist);
        const up = new AFRAME.THREE.Vector3(0, 1, 0);
        obj.quaternion.setFromUnitVectors(up, dir.normalize());
      },
      refreshLinks() {
        this.links.forEach(l => this.updateLink(l.el, l.a.object3D.position, l.b.object3D.position));
      }
    });

    AFRAME.registerComponent('gentle-float', {
      schema: { amp: { default: 0.25 }, speed: { default: 0.6 } },
      init() {
        this.t0 = Math.random() * 1000;
        this.origin = this.el.object3D.position.clone();
      },
      tick(time, dt) {
        const t = (time + this.t0) * 0.001 * this.data.speed;
        const o = this.origin;
        this.el.object3D.position.set(
          o.x + Math.sin(t * 1.1) * 0.08,
          o.y + Math.sin(t * 0.9) * this.data.amp,
          o.z + Math.cos(t * 1.3) * 0.08
        );
      }
    });

    AFRAME.registerComponent('bubble-node', {
      schema: { id: { type: 'string' }, radius: { default: 0.7 }, color: { default: '#b6f3ff' } },
      init() {
        const { radius, color } = this.data;
        this.el.setAttribute('geometry', `primitive: sphere; radius: ${radius}`);
        this.el.setAttribute('material', `color: ${color}; opacity: 0.35; metalness: 0; roughness: 0.2; transparent: true; side: double`);
        this.el.setAttribute('class', 'bubble');
        this.el.setAttribute('gentle-float', '');
        this.el.dataset.id = this.data.id;
        this.system.addNode(this.el);
        this.el.addEventListener('bubble-selected', () => {
          this.el.setAttribute('animation__pulse', 'property: scale; to: 1.15 1.15 1.15; dur: 180; dir: alternate; loop: 3');
        });
        this.el.addEventListener('bubble-deselected', () => {
          this.el.removeAttribute('animation__pulse');
          this.el.setAttribute('scale', '1 1 1');
        });
      },
      update(old) {
        if (old.radius !== this.data.radius) {
          this.el.setAttribute('geometry', `primitive: sphere; radius: ${this.data.radius}`);
        }
      },
      remove() {
        this.system.removeNode(this.el);
      }
    });

    AFRAME.registerComponent('network-links', {
      tick() {
        this.el.sceneEl.systems['bubble-network'].refreshLinks();
      }
    });

    AFRAME.registerComponent('bubble-input', {
      init() {
        this.system = this.el.sceneEl.systems['bubble-network'];
        this.camera = document.getElementById('cam');
        this.raycaster = new AFRAME.THREE.Raycaster();
        this.touching = false;
        this.downTime = 0;
        this.start = { x: 0, y: 0 };
        this.activeBubble = null;
        this.dragging = false;
        this.dragStartPos = null;
        this.bindEvents();
      },
      bindEvents() {
        window.addEventListener('touchstart', e => this.onDown(e), { passive: false });
        window.addEventListener('touchmove', e => this.onMove(e), { passive: false });
        window.addEventListener('touchend', e => this.onUp(e));
      },
      pickBubble() {
        const camObj = this.camera.object3D;
        const dir = new AFRAME.THREE.Vector3(0, 0, -1).applyQuaternion(camObj.quaternion).normalize();
        this.raycaster.set(camObj.getWorldPosition(new AFRAME.THREE.Vector3()), dir);
        const meshes = this.system.nodes.map(n => n.getObject3D('mesh')).filter(Boolean);
        const hits = this.raycaster.intersectObjects(meshes, true);
        if (hits.length) return hits[0].object.el;
        return null;
      },
      onDown(e) {
        const t = e.touches[0];
        this.touching = true;
        this.downTime = performance.now();
        this.start.x = t.clientX;
        this.start.y = t.clientY;
        this.activeBubble = this.pickBubble();
        if (this.activeBubble) {
          this.dragStartPos = this.activeBubble.object3D.position.clone();
        }
      },
      onMove(e) {
        if (!this.touching || !this.activeBubble) return;
        const t = e.touches[0];
        const dx = t.clientX - this.start.x;
        const dy = t.clientY - this.start.y;
        if (Math.hypot(dx, dy) < 8) return;
        e.preventDefault();
        this.dragging = true;
        const camObj = this.camera.object3D;
        const right = new AFRAME.THREE.Vector3(1, 0, 0).applyQuaternion(camObj.quaternion);
        const up = new AFRAME.THREE.Vector3(0, 1, 0).applyQuaternion(camObj.quaternion);
        const scale = 0.005 * camObj.position.distanceTo(this.activeBubble.object3D.position);
        const target = this.dragStartPos.clone()
          .addScaledVector(right, dx * scale)
          .addScaledVector(up, -dy * scale);
        this.activeBubble.object3D.position.copy(target);
        this.system.refreshLinks();
      },
      onUp(e) {
        if (!this.touching) return;
        const elapsed = performance.now() - this.downTime;
        const dx = (e.changedTouches[0]?.clientX || this.start.x) - this.start.x;
        const dy = (e.changedTouches[0]?.clientY || this.start.y) - this.start.y;
        const moved = Math.hypot(dx, dy) > 10;
        const targetBubble = this.activeBubble || this.pickBubble();
        if (this.dragging) {
          // already moved bubble
        } else if (targetBubble) {
          if (elapsed > 650) {
            const current = parseFloat(targetBubble.getAttribute('bubble-node').radius);
            const next = Math.min(2.5, current + 0.35);
            targetBubble.setAttribute('bubble-node', `radius: ${next}`);
          } else {
            if (this.system.selected && this.system.selected !== targetBubble) {
              this.system.link(this.system.selected, targetBubble);
              this.system.select(targetBubble);
            } else {
              this.system.select(targetBubble);
            }
          }
        } else {
          const pos = this.camera.object3D.getWorldPosition(new AFRAME.THREE.Vector3());
          const dir = new AFRAME.THREE.Vector3(0, 0, -1).applyQuaternion(this.camera.object3D.quaternion).normalize();
          const target = pos.clone().addScaledVector(dir, 3.5);
          createBubble(target);
        }
        this.touching = false;
        this.dragging = false;
        this.activeBubble = null;
      }
    });

    function createBubble(pos) {
      const scene = document.querySelector('a-scene');
      const id = `b${Date.now().toString(36)}${Math.floor(Math.random() * 99)}`;
      const el = document.createElement('a-entity');
      const color = palette[Math.floor(Math.random() * palette.length)];
      el.setAttribute('position', `${pos.x} ${pos.y} ${pos.z}`);
      el.setAttribute('bubble-node', `id: ${id}; radius: ${rand(0.5, 1.1).toFixed(2)}; color: ${color}`);
      el.setAttribute('animation__fade', 'property: material.opacity; from: 0; to: 0.35; dur: 220; easing: easeOutQuad');
      scene.appendChild(el);
      return el;
    }

    function seedBubbles() {
      const scene = document.querySelector('a-scene');
      const sys = scene.systems['bubble-network'];
      let previous = null;
      for (let i = 0; i < 6; i++) {
        const p = new AFRAME.THREE.Vector3(rand(-2, 2), rand(0.5, 3), rand(-2, 2));
        const b = createBubble(p);
        if (previous) sys.link(previous, b);
        previous = b;
      }
    }

    document.querySelector('a-scene').addEventListener('loaded', () => {
      seedBubbles();
      const scene = document.querySelector('a-scene');
      scene.setAttribute('bubble-input', '');
    });
  </script>
</body>
</html>
